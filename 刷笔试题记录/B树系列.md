> 本文参考以下文章：
>
> http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html
>
> **本文每个大部分的结构是：定义->性质->插入节点时的平衡操作->和下一部分的关系**
>
> 另外本文最后给出所有树的效率对比图



#### 一、二叉搜索树(排序二叉树、有序二叉树)

- 1.1性质：

  指一棵空树或者具有下列性质的二叉树：

  1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
  2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
  3. 任意节点的左、右子树也分别为二叉查找树。
  4. 没有键值相等的节点（no duplicate nodes）。

- 1.2总结

  二叉搜索树和二分查找一样，插入和查找的时间复杂度均为lgN，但是在最坏的情况下仍然会有N的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是后面要讲的平衡查找树的内容了。下文首先讲解平衡查找树的最简单的一种：2-3查找树。

  ​

> **(二叉查找树和平衡二叉树关系)**
>
> 前面介绍了[二叉查找树](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)(Binary Search Tree)，他对于大多数情况下的查找和插入在效率上来说是没有问题的，但是他在最差的情况下效率比较低。本文及后面文章介绍的平衡查找树的数据结构能够保证在最差的情况下也能达到lgN的效率，要实现这一目标我们需要保证树在插入完成之后始终保持平衡状态，这就是**平衡查找树(Balanced Search Tree)。**
>
> **平衡查找树**具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。常用算法有红黑树、AVL、Treap、伸展树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O（log（n）），大大降低了操作的时间复杂度。
>
> 在一棵具有N 个节点的树中，我们希望该树的高度能够维持在lgN左右，这样我们就能保证只需要lgN次比较操作就可以查找到想要的值。不幸的是，每次插入元素之后维持树的平衡状态太昂贵。所以这里会介绍一些新的数据结构来保证在最坏的情况下插入和查找效率都能保证在对数的时间复杂度内完成。本文首先介绍2-3查找树(2-3 Search Tree)，后面会在此基础上介绍红黑树和B树。



#### 二、平衡查找树之2-3树

- 2.1和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：

  1. 要么为空，要么：
  2. 对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。
  3. 对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个根节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。

  如果中序遍历2-3查找树，就可以得到排好序的序列。在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。2-3树如下图：

![平衡查找树之2-3树](E:\笔记\刷笔试题记录\图片\平衡查找树之2-3树.png)

- 2.2插入操作(具体插入情况看开头链接文章)
  - 往一个2-node节点插入，将该节点变成3-node节点就OK。
  - 往一个3-node节点插入，分几种情况：
    - 只有一个3-node节点。直接插入变成4-node节点，把中间的key提上去。
    - 节点是3-node，父节点是2-node。直接插入变成4-node节点，把中间key提上去使父节点变成3-node节点。
    - 节点是3-node，父节点也是3-node。直接插入变成4-node节点，把中间key提上去使父节点变成4-node节点，递归下去知道父节点不是4-node节点。
    - 根节点分裂，当根节点变成4-node节点时，就需要将根节点查分为两个2-node节点，树的高度加1。
- 2.3本地操作
  - 将一个4-node拆分为2-3node涉及到6种可能的操作。这4-node可能在跟节点，也可能是2-node的左子节点或者右子节点。或者是一个3-node的左，中，右子节点。所有的这些改变都是本地的，不需要检查或者修改其他部分的节点。所以只需要常数次操作即可完成2-3树的平衡。
  - 这些本地操作保持了2-3树的平衡。对于4-node节点变形为2-3节点，变形前后树的高度没有发生变化。只有当跟节点是4-node节点，变形后树的高度才加一。
- 2.4 2-3树的查找效率
  - 在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN
  - 在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN

>**(2-3树和红黑树，B树的关系)**
>
>直接实现2-3树比较复杂，因为：
>
>1. 需要处理不同的节点类型，非常繁琐
>2. 需要多次比较操作来将节点下移
>3. 需要上移来拆分4-node节点
>4. 拆分4-node节点的情况有很多种
>
>2-3查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。在2-3查找树基础上改进的红黑树不仅具有较高的效率，并且实现起来较2-3查找树简单。
>
>但是2-3查找树作为一种比较重要的概念和思路对于后文要讲到的红黑树和B树非常重要。

#### 三、平衡查找树之红黑书

- 3.1定义

  红黑树的主要是想对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。如下图

  ![红黑树结构](E:\笔记\刷笔试题记录\图片\红黑树结构.png)

  根据以上描述，红黑树**定义**如下：

  红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：

  - 红色节点向左倾斜
  - 一个节点不可能有两个红色链接
  - 整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。

  下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。如图：

  ![红黑书变成2-3树](E:\笔记\刷笔试题记录\图片\红黑书变成2-3树.png)

- 3.2平衡化涉及的操作

  - 旋转，分左旋和右旋。

    - 通常左旋操作用于将一个向右倾斜的红色链接旋转为向左链接。

      ![红黑树左旋](E:\笔记\刷笔试题记录\图片\红黑树左旋.gif)

    - 右旋是左旋的逆操作

      ![红黑树右旋](E:\笔记\刷笔试题记录\图片\红黑树右旋.gif)

    - 颜色反转，当出现一个临时的4-node的时候，即一个节点的两个子节点均为红色，如下图：

      ![红黑树flipcolor前](E:\笔记\刷笔试题记录\图片\红黑树flipcolor前.png)

      ![红黑树flipcolor后](E:\笔记\刷笔试题记录\图片\红黑树flipcolor后.png)

      这其实是个A，E，S 4-node连接，我们需要将E提升至父节点，操作方法很简单，就是把E对子节点的连线设置为黑色，自己的颜色设置为红色。

- 3.3插入操作

  ![红黑树插入操作](E:\笔记\刷笔试题记录\图片\红黑树插入操作.png)

- 3.4分析

  - 对红黑树的分析其实就是对2-3查找树的分析，红黑树能够保证符号表的所有操作即使在最坏的情况下都能保证对数的时间复杂度，也就是树的高度。
  - 详情见开头链接和文末对比图。

- 3.5应用

  - Java中的java.util.TreeMap,java.util.TreeSet
  - C++ STL中的：map,multimap,multiset



>前边讲解了自平衡查找树中的[2-3查找树](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。
>
>但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。
>
>接下来将介绍在文件系统以及数据库系统中应用非常广泛的另外一种平衡树结构：B树。



> 维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化**大块数据的读和写操作**。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在**数据库**和**文件系统**。”

#### 四、平衡查找树之B树

- 4.1定义：

  ​	**关于子节点的：**

  ​       1.定义任意非叶子结点最多只有M个儿子；且M>2；

  ​       2.根结点的儿子数为[2, M]；

  ​       3.除根结点以外的非叶子结点的儿子数为[M/2, M]；

  ​	**关于关键字的：**

  ​       4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）

  ​       5.非叶子结点的关键字个数=指向儿子的指针个数-1；

  ​       6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；

  ​       7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；

  ​       8.所有叶子结点位于同一层；

  ![B-树](E:\笔记\刷笔试题记录\图片\B-树.JPG)

- 4.2 B树特性：

    1.关键字集合分布在整颗树中；

    2.任何一个关键字出现且只出现在一个结点中；

    3.搜索有可能在非叶子结点结束；

    4.其搜索性能等价于在关键字全集内做一次二分查找；

    5.自动层次控制；

- 4.3性能分析：

  - 由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：O(log2N),N为关键字个数。
  - 所以B-树的性能总是等价于二分查找（与M值无关），也就没有二叉搜索树平衡的问题。
  - 由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；

#### 五、平衡查找树之B+树

> B+树是B-树的变体，也是一种多路搜索树：

- 5.1定义：

  ​       1.其定义基本与B-树同，除了：

  ​       2.非叶子结点的子树指针与关键字个数相同；

  ​       3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；

  ​       5.为所有叶子结点增加一个链指针；

  ​       6.所有关键字都在叶子结点出现；

![B+树](E:\笔记\刷笔试题记录\图片\B+树.JPG)

B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

- 5.2 B+的特性：

  1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；

​       2.不可能在非叶子结点命中；

​       3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；

​       4.更适合文件索引系统；

#### 六、平衡查找树之B*树

> 是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；

![B星树](E:\笔记\刷笔试题记录\图片\B星树.JPG)



- B*树定义了非叶子结点关键字个数至少为**(2/3)M**，即块的最低使用率为2/3（代替B+树的1/2）；


- **B+树的分裂**：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据

复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父

结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

-  **B*树的分裂**：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分

数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字

（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之

间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；

- 所以，B*树分配新结点的概率比B+树要低，空间使用率更高；

#### 七、文件系统中的B/B+树应用

>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。
>
>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。



文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：

- 每次新建一个节点的同时，直接申请一个页的空间( 512或者1024)，这样就保证一个节点在磁盘上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。如，将B树的度M设置为1024，这样在前面的例子中，600亿个元素中只需要小于4次查找即可定位到某一存储位置。
- 同时在B+树中，内节点只存储导航用到的key，并不存储具体值，这样内节点个数较少，能够全部读取到主存中，外接点存储key及值，并且顺序排列，具有良好的空间局部性。所以B及B+树比较适合与文件系统的数据结构。

#### 八、trie树(字典树、单词查找树)

- 字典树（Trie）可以保存一些字符串->值的对应关系。基本上，它跟 Java 的 HashMap 功能相同，都是 key-value 映射，只不过 Trie 的 key 只能是字符串。


- Trie 的强大之处就在于它的时间复杂度。它的插入和查询时间复杂度都为 O(k) ，其中 k 为 key 的长度，与 Trie 中保存了多少个元素无关。Hash 表号称是 O(1) 的，但在计算 hash 的时候就肯定会是 O(k) ，而且还有碰撞之类的问题；Trie 的缺点是空间消耗很高。
- Trie树，又称单词查找树或键树，是一种树形结构，是一种**哈希树的变种**。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。
- Trie的核心思想是空间换时间。利用**字符串的公共前缀**来降低查询时间的开销以达到提高效率的目的。

#### 九、哈希树

- 9.1质数分辨定理

  - 简单地说就是：n个不同的质数可以“分辨”的连续整数的个数和他们的乘积相等。“分辨”就是指这些连续的整数不可能有完全相同的余数序列。

  - 例如：

    ​	从2起的连续质数，连续10个质数就可以分辨大约M(10) =2*3*5*7*11*13*17*19*23*29= 6464693230 个数，已经超过计算机中常用整数（32bit）的表达范围。连续100个质数就可以分辨大约M(100) = 4.711930 乘以10的219次方。

- 9.2哈希树插入

  我们选择质数分辨算法来建立一棵哈希树。
  选择从2开始的连续质数来建立一个十层的哈希树。第一层结点为根结点，根结点下有2个结点；第二层的每个结点下有3个结点；依此类推，即每层结点的子节点数目为连续的质数。到第十层，每个结点下有29个结点。
  同一结点中的子结点，从左到右代表不同的余数结果。
  例如：第二层结点下有三个子节点。那么从左到右分别代表：除3余0，除3余1，除3余2.
  对质数进行取余操作得到的余数决定了处理的路径。

  下面我们以随机的10个数的插入为例，来图解HashTree的插入过程

![哈希树的插入过程](E:\笔记\刷笔试题记录\图片\哈希树的插入过程.png)

