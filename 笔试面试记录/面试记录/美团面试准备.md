### 1、java的方法调用机制

- java在被编译成class文件的过程中，并不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都是**符号引用**，而不是方法在实际运行时内存布局中的**入口地址**(即直接引用)。


- 所以有些方法在类加载过程的**解析阶段**被确定，有些甚至要等到**实际运行时**才能确定。
- 类加载过程分：加载-->验证-->准备-->解析-->初始化
  - **解析调用**就是指在类加载的解析阶段把涉及的符号引用全部转换为可确定的直接引用，这种转换能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个调用版本在运行期间不可变。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用就称为解析。
  - 那么哪些方法的可能调用版本总是固定的一个呢？就是那些无法被重写、无法产生多态行为的方法，这些方法在Java中被称为**非虚方法**。那么Java中哪些方法是非虚的呢？
  - 非虚方法有：静态方法，私有方法，实例构造器，父类方法，final方法。
- 一些概念
  - 变量被声明时的类型叫做变量的**静态类型**，变量所引用对象的真实类型叫做变量的**实际类型**。
  - 一个方法所属的对象叫做**方法的接收者**。方法的接收者和方法的参数统称为**方法的宗量**。
- 静态分派
  - 静态分派发生在编译期，分派是**根据静态类型信息**发生。静态分派发生在编译阶段，因此静态分派的动作不是由虚拟机来执行的；静态分派是根据**接收者的静态类型**和**方法参数的静态类型**来定位方法执行版本的。静态分派的典型应用是方法**重载**。
- 动态分派
  - 在运行期根据实际类型确定方法执行版本的本派过程叫做动态分派。记住：动态分派选择的依据是接收者的实际类型。方法参数的类型在动态分派选择时将不再起到作用。动态分派的重要体现是**重写**。
- 调用虚方法时的步骤（**多态的实现原理**）
  - 在前面，我们明确了非虚方法和虚方法的区别，可以重写的方法一定是虚方法，在调用虚方法时使用的指令是invokevirtual，invokevirtual指令的运行时解析过程大致分为以下步骤（极简描述）：
    - （1）找到操作数栈顶的第一个元素所指向对象的**实际类型**，记作C。也就是找到接收者的实际类型。
    - （2）如果在类型C中找到相符的方法，进行校验，返回方法的直接引用，查找结束，校验不通过，抛异常。
    - （3）否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和校验过程。
    - （4）如果始终没找到，抛异常。
- 静态分派是多分派
  - （1）静态分派中，编译器要判断接受者的静态类型，确定是哪个类上的方法，这个时候已经判定了接受者这个宗量了；
  - （2）编译器还需要确定参数的静态类型，已确定重载方法中的版本，这个时候又判定了参数这个宗量。
    所以静态分派是多分派。
- 动态分派是单分派
  - （3）到了运行期，虚拟机首先就是判断接收者的实际类型，去其上搜索匹配的方法，只判定了接收者的实际类型，方法参数的类型已经不重要了。所以动态分派是单分派。

### 2、最熟悉哪种模式？

- 代理模式
  - **什么是代理模式？**提供了对目标对象另外的访问方式;即通过代理对象访问目标对象
  - **这样做的好处是**:
    - 可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。
    - 这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法。
  - java中的三种代理模式
    - 静态代理，实现一个类，同名方法中调用目标类的方法。必须实现了接口。
    - 动态代理，通过Proxy.newProxyInstance(类加载器，接口，调用处理器)获得代理对象，调用处理器中实现invoke()方法，invoke()方法中添加代理逻辑。
    - Cglib代理，也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.

### 3、java垃圾回收机制

- java运行时内存分：栈，堆，方法区，本地方法栈，程序计数器。垃圾回收机制针对堆内存。
- 垃圾回收的概念就是JAVA虚拟机（JVM）回收那些不再被引用的对象内存的过程。
- **如何判断一个对象可回收**？引用计数算法（不可行）、根搜索算法。（GC Roots有哪些？）
- **垃圾收集算法**
  - 标记－清除算法（内存碎片）
  - 标记－整理算法（主要解决内存碎片化的问题）
  - 复制算法（对半分会浪费内存，改进方法是Eden和Survivor区，但是有担保问题）
  - 分代收集算法
    - 基本原理：根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
    - 新生代 每次垃圾收集都有大量的内存对象被收集，只有少量存活，对象为朝生夕死采用复制算法
    - 老年代 对象存活比例较高，也没有更多的内存进行担保，采用标记-清理或标记整理进行内存回收
- **G1收集器**（Garbage First）避免全区域的GC，把整个堆划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域（这就是Garbage First的由来）。

### 4、进程线程，进程通信方式

### 5、linux根目录下的结构。

**/**：根目录，只有root用户具有该目录下的写权限。请注意，/root是root用户的主目录，这与/.不一样

**/dev**：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt。

**/proc** - 进程信息，此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录

**/usr**：应用程序存放目录，/usr/bin存放应用程序，/usr/share存放共享数据，/usr/lib存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local:存放软件升级包。/usr/share/doc:系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录，使用 man ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间

**home**：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~test表示用户test的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据

**bin** --- 系统启动时需要的执行文件（二进制）

**/lib** - 系统库，包含支持位于/bin和/sbin下的二进制文件的库文件.

### 6、linux命令

网络命令：ifconfig，route，ping，traceroute，netstat，telnet，

性能监控和优化命令：top，free，iostat，vmstat，lsof，

磁盘存储:df，du

文件目录操作命令：ls，cd，pwd，mkdir，rm，rmdir，mv，cp，touch，cat，more，

### 7、数据库查询或存储数据量很大时怎么处理？redis和memcached

​     1.通过高速服务器Cache缓存数据库数据，Memcached         内存Key-Value Cache

​     2.内存数据库，Redis                     内存数据库

- Memcached工作方式

- Memcached是高性能的分布式内存缓存服务器,通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web等应用的速度、 提高可扩展性。

  - 1.检查用户请求的数据是缓存中是否有存在，如果有存在的话，只需要直接把请求的数据返回，无需查询数据库。
  - 2.如果请求的数据在缓存中找不到，这时候再去查询数据库。返回请求数据的同时，把数据存储到缓存中一份。
  - 3.保持缓存的“新鲜性”，每当数据发生变化的时候（比如，数据有被修改，或被删除的情况下），要同步的更新缓存信息，确保用户不会在缓存取到旧的数据。

- redis原理

  - Redis作为一个高性能的key-value数据库具有以下特征： 
    - 多样的数据模型 ，String、Hash、List、Set和Sorted Set
    - 持久化 
    - 主从同步 
  - Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、 list(链表)、set(集合)和zset(有序集合)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。
  - 在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步

- 对比

  - 总的来说，可以把Redis理解为是对Memcached的拓展，是更加重量级的实现，提供了更多更强大的功能。具体来说：

  - **性能上**都很出色，具体到细节，由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比

    Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。

  - **内存空间和数据量大小：**

    ​     MemCached可以修改最大内存，采用LRU算法。Redis增加了VM的特性，突破了物理内存的限制。

  - **操作便利上：**

    ​     MemCached数据结构单一，仅用来缓存数据，而Redis支持更加丰富的数据类型，也可以在服务器端直接对数据进行丰富的操作,这样可以减少网络IO次数和数据体积。

  - **可靠性上：**

    ​     MemCached不支持数据持久化，断电或重启后数据消失，但其稳定性是有保证的。Redis支持数据持久化和数据恢复，允许单点故障，但是同时也会付出性能的代价。

  - **应用场景：**

    ​     Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息等）。

    ​     Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。

  - **集群**

    新版本（3.0）的Redis是指集群分布式，也就是说集群本身均衡客户端请求，各个节点可以交流，可拓展行、可维护性更强大。

### 8、sql之left join、right join、inner join的区别

left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 
right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
inner join(等值连接) 只返回两个表中联结字段相等的行

### 9、二叉搜索树，AVL树，2-3node树，红黑树，B树，B+树，B*树，字典树，哈希树

### 10、进程线程区别

- 定义上：进程是某个数据集合上的一次运行活动；线程是进程内的一个执行路径。
- 角色：进程是OS分配资源的基本单位；线程是CPU调度的基本单位。
- 资源共享方面：进程间无法共享资源，而线程共享所在进程的地址空间和其他资源。同时线程还有自己的栈和栈指针，程序计数器等寄存器。
- 独立性：进程有自己的地址空间，线程没有，线程必须依附于进程而存在。
- 开销：进程切换的开销比骄大，线程现对较小。

### 11、进程间通信

- **管道**，半双工的，数据只能单向流动，而且只能在父子进程间使用。
- **有名管道**，也是半双工，但是允许无亲缘关系进程间的通信。
- **信号量**，信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- **消息队列**，消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- **信号**， 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- **共享内存**，共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。
- **套接字** ，套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机间及其间的进程通信。


### 12、sql注入

####SQL注入就是通过把SQL命令插入到Web[表单](https://baike.baidu.com/item/%E8%A1%A8%E5%8D%95)提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

####防护：对输入验证或过滤，不要暴露过多错误信息，关键信息加密存储，限制web应用的权限

### 13、HashMap，数据结构-关键属性-计算index值(hash(key)&(length-1)，扰动函数)-put和get

### 14、ConcurrentHashMap使用分段锁，继承ReentrantLock

###15、ReentrantLock 相对于固有锁synchronized，**同样是可重入的**，在某些vm版本上提供了比固有锁更高的性能，提供了更**丰富的锁特性**，比如可中断的锁，可等待的锁，平等锁以及非块结构的加锁。

### 16、happens-before原则；Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性

### 17、ThreadLocal不是用来解决共享对象的多线程访问问题的，说ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()来实现的，而是通过每个线程中的new 对象的操作来创建的对象，每个线程创建一个。当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始化值的时候最适合使用ThreadLocal。

### 18、单例模式，饿汉式，枚举，懒汉式（性能差的，双重检查锁定写法）

###19、GC Roots：虚拟机栈（栈帧中的本地变量表）中引用的对象。方法区中的类静态属性引用的对象。方法区中的常量引用的对象。本地方法栈中的JNI（一般说的Native）的引用的对象。

### 20、内存泄漏的定义：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。原因：静态集合类引起内存泄露；当集合里面的对象属性被修改后，再调用remove（）方法时不起作用；各种连接要close()；调用别的模块时注意将引用释放。

### 21、NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接接收读或写）。因此，单个线程可以监听多个数据通道。非阻塞的，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

### 22、redis和memcache、SDS，链表、字典、跳跃表，压缩列表、

**1. Redis中，并不是所有的数据都一直存储在内存中的，这是和Memcached相比一个最大的区别。**

**2. Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。**

**3. Redis支持数据的备份，即master-slave模式的数据备份。**

**4. Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。**

**Redis在很多方面具备数据库的特征，或者说就是一个数据库系统，而Memcached只是简单的K/V缓存**

### 23、Spring的事务管理分为声明式跟编程式。声明式就是在Spring的配置文件中进行相关配置；编程式就是用注解的方式写到代码里。事务配置分DataSource、TransactionManager和代理机制三部分

### 24、REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED

