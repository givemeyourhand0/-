#### 一、tcp/http

##### 1、TCP首部。

- IP数据报（IP首部+TCP报文段（TCP首部+TCP数据））
- TCP首部，5*32位，20字节
  - 16源端口号+16目的端口号，用于寻找发送端和接收端的应用进程，加上IP首部的源端IP及终端IP，唯一的确认一个TCP连接。
  - 32位序号：标识发送的数据字节流，标识在这个报文段中的第一个数据字节。
  - 32位确认序号：ACK为1时有效，上次成功收到的数据字节序号+1（如接收到的为1024--2048，则返回2049）。
  - 4位首部长度：首部中32bits字的数目，TCP最多有60字节的长度，除去任选字段，正常为20字节。
  - 6bits：URG紧急指针；ACK确认序号有效；PSH接收方应尽快将此报文段交给应用层；RST重建连接；SYN同步序号，用来发起一个新连接；FIN发端完成发送任务。
  - 16位窗口大小：TCP流量控制，字节数，起始于确认序列号指明的值，接收端期望收到的字节，最大为65535.
  - 16位检验和：包括计算TCP首部和数据综合的二进制反码和检验和。
  - 16位紧急指针：URG为1时有效，正向的偏移量，加上序号字段值表示最后一个字节的序号。

##### 2、TCP为什么是可靠的？

- **面向连接：**意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信。
- **TCP的可靠性**是针对UDP不可靠传输来说的，另外传输层下的IP层也是不可靠的。所以TCP的可靠性是指基于不可靠的IP层在传输层提供可靠的数据传输服务，主要是指传输数据不会损坏或丢失，而且所有数据都是按照发送顺序进行传送（通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。）。
- 实现TCP的可靠传输有以下**机制**：
  1，校验和（校验数据是否损坏）；
  2，定时器（分组丢失则重传）；
  3，序号（用于检测丢失的分组和冗余的分组）；
  4，确认（接收方告知发送方正确接收分组以及期望的下一个分组）；
  5，否定确认（接收方通知发送方未被正确接收的分组）；
  6，窗口和流水线（用于增加信道的吞吐量）。
- 至于数据是否在中途被修改或者被窃听，这应该是属于安全性问题。提高安全性最根本的办法就是加密数据，比如远程登录用ssh而非telnet。

##### 3、三次握手四次挥手？

- **为什么是三次握手？**

  举个打电话的例子：

  A：喂，我是A，能听到吗？

  B：喂，我是B，我能听到你，你能听到我吗?

  A：能听到。

  .......连接建立，开始聊天。

  因为能够使双方都知道对方设备是好的的最少次数就是三次，二次会出现客户端的某个连接请求延时到达，服务端还是会分配资源建立连接。四次握手是浪费资源。

  ![三次握手](E:\笔记\笔试面试记录\图片\三次握手.png)

  ​

- **为什么是四次挥手？**

  1、当主机A确认发送完数据且知道B已经接受完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给主机B。

  2、主机B收到A发送的FIN，表示收到了，就会发送ACK回复。

  3、但这是B可能还在发送数据，没有想要关闭数据口的意思，所以FIN与ACK不是同时发送的，而是等到B数据发送完了，才会发送FIN给主机A。

  4、A收到B发来的FIN，知道B的数据也发送完了，回复ACK， A等待2MSL以后，没有收到B传来的任何消息，知道B已经收到自己的ACK了，A就关闭链接，B也关闭链接了。

  ![四次挥手](E:\笔记\笔试面试记录\图片\四次挥手.png)

  ​

- **A为什么等待2MSL，从TIME_WAIT到CLOSE？**

   在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

##### 4、[TCP和UDP](http://blog.csdn.net/li_ning_/article/details/52117463)

- 区别总结

  - TCP面向连接，传输数据前需要建立连接；UDP无连接。

  - 每条TCP连接只能是点对点的；UDP支持一对一，一对多，多对一和多对多的交互通信。

  - TCP提供可靠的服务，通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。

    UDP尽最大努力交付数据，UDP没有拥塞控制，因此网络出现拥塞时不会使源主机的发送效率降低。

  - TCP面向字节流，意思是TCP把数据看成一串无结构的字节流；UDP是面向报文的。

  - TCP首部20字节；UDP首部8字节。

  - TCP的逻辑通信信道是全双工的可靠信道；UDP则是不可靠信道。

  - TCP要求的系统资源多，UDP要求的较少。

- socket编程时，TCP和UDP的不同。

  - TCP服务端socket编程步骤
    - 用socket()函数，创建一个socket。socket(PF_INET, SOCK_STREAM, 0)，这表示建立一个socket用于流式网络通讯。  **SOCK_STREAM**这种的特点是面向连接的；而**SOCK_DGRAM**这种是User Datagram Protocol协议的网络通讯，它是无连接的。
    - 设置socket参数，用setsockopt();*可选
    - 用bind()函数绑定IP、端口信息到socket上
    - 用listen()开启监听
    - 接收客户端上来的连接，用accept()
    - 收发数据，用send()和recv()，或者read()和write()
    - 关闭网络连接
    - 关闭监听
  - TCP客户端socket编程步骤
    - 用socket()函数，创建一个socket
    - 设置socket参数，用setsockopt();*可选
    - 用bind()函数绑定IP、端口信息到socket上*可选
    - 设置要连接的对方的IP、端口等属性
    - 连接服务器，用connect()
    - 收发数据，用send()和recv()，或者read()和write()
    - 关闭网络连接
  - UDP服务端socket编程步骤
    - 用socket()函数，创建一个socket
    - 设置socket参数，用setsockopt();*可选
    - 用bind()函数绑定IP、端口信息到socket上
    - 用recvfrom()循环接收数据。
    - 关闭网络连接
  - UDP客户端socket编程步骤
    - 用socket()函数，创建一个socket
    - 设置socket参数，用setsockopt();*可选
    - 用bind()函数绑定IP、端口信息到socket上*可选
    - 设置对方的IP地址和端口等属性
    - 用sendto()发送数据
    - 关闭网络连接

##### 5、[http请求报文](http://network.chinabyte.com/401/13238901.shtml)

![http请求报文](E:\笔记\笔试面试记录\图片\http请求报文.jpg)

　　● User-Agent：产生请求的[浏览器](http://www.chinabyte.com/keyword/%E6%B5%8F%E8%A7%88%E5%99%A8/)类型;

　　● Accept：客户端可识别的响应内容类型列表;星号 “ * ” 用于按范围将类型分组，用 “ */* ” 指示可接受全部类型，用“ type/* ”指示可接受 type 类型的所有子类型;

　　● Accept-Language：客户端可接受的自然语言;

　　● Accept-Encoding：客户端可接受的编码压缩格式;

　　● Accept-Charset：可接受的应答的字符集;

　　● Host：请求的主机名，允许多个[域名](http://www.chinabyte.com/keyword/%E5%9F%9F%E5%90%8D/)同处一个IP 地址，即虚拟主机;

　　● connection：连接方式(close 或 keepalive);

　　● Cookie：[存储](http://storage.chinabyte.com/)于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;

​	空行：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头;

##### 6、http响应报文

![http响应报文](E:\笔记\笔试面试记录\图片\http响应报文.png)

- 状态码

    1xx：表示服务器已接收了客户端请求，客户端可继续发送请求;

  　　2xx：表示服务器已成功接收到请求并进行处理;

  　　3xx：表示服务器要求客户端重定向;

  　　4xx：表示客户端的请求有非法内容;

  　　5xx：表示服务器未能正常处理客户端的请求而出现意外错误;

-   200 OK：表示客户端请求成功;

    301 - 资源（网页等）被永久转移到其它URL

    302临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI

    400 Bad Request：表示客户端请求有语法错误，不能被服务器所理解;

  　    401 Unauthonzed：表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用;

  　　403 Forbidden：表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因;

  　　404 Not Found：请求的资源不存在，例如，输入了错误的URL;

  　　500 Internal Server Error：表示服务器发生不可预期的错误，导致无法完成客户端的请求;

  　　503 Service Unavailable：表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常;

- 响应头部

  - Location：Location响应报头域用于重定向接受者到一个新的位置。例如：客户端所请求的页面已不存在原先的位置，为了让客户端重定向到这个页面新的位置，服务器端可以发回Location响应报头后使用重定向语句，让客户端去访问新的域名所对应的服务器上的资源;
  - Server：Server 响应报头域包含了服务器用来处理请求的软件信息及其版本。它和 User-Agent 请求报头域是相对应的，前者发送服务器端软件的信息，后者发送客户端软件(浏览器)和[操作系统](http://soft.chinabyte.com/os/)的信息。
  - Vary：指示不可缓存的请求头列表;
  - Connection：连接方式;
    - 对于请求来说：close(告诉[WEB 服务器](http://www.chinabyte.com/keyword/web%E6%9C%8D%E5%8A%A1%E5%99%A8/)或者[代理服务器](http://www.chinabyte.com/keyword/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/)，在完成本次请求的响应后，断开连接，不等待本次连接的后续请求了)。keepalive(告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求);
    - 对于响应来说：close(连接已经关闭); keepalive(连接保持着，在等待本次连接的后续请求); 
  - Keep-Alive：如果浏览器请求保持连接，则该头部表明希望WEB 服务器保持连接多长时间(秒);例如：Keep-Alive：300;
  - WWW-Authenticate：WWW-Authenticate响应报头域必须被包含在401 (未授权的)响应消息中，这个报头域和前面讲到的Authorization 请求报头域是相关的，当客户端收到 401 响应消息，就要决定是否请求服务器对其进行验证。如果要求服务器对其进行验证，就可以发送一个包含了Authorization 报头域的请求;
  - 空行：最后一个响应头部之后是一个空行，发送回车符和换行符，通知服务器以下不再有响应头部。


#### 二、osi模型

##### 1、osi模型和tcp/ip模型的区别

首先得知道osi模型的设计初衷，ISO组织研究的网络互联模型，说白了就是一个规范，每一层实现各自的功能和协议，并完成与相邻层的接口通信，大家遵守规范，那么就可以互联网络。

![OSI七层模型](E:\笔记\笔试面试记录\图片\OSI七层模型.png)

但是OSI模型过于庞大和复杂，所以技术人员又实现了TCP/IP模型，随后得到广泛应用。

![TCP-IP五层与协议](E:\笔记\笔试面试记录\图片\TCP-IP五层与协议.png)

##### 2、应用层协议有哪些？

![TCP-IP协议](E:\笔记\笔试面试记录\图片\TCP-IP协议.jpg)

基于TCP的有：HTTP、FTP、TELNET、SMTP

基于UDP的有：SNMP、TFTP、NTP

SNMP，简单网络管理协议，用于网络管理的协议，用于网络设备的管理。

TFTP，简单文件传输协议

NTP，网络时间协议(Network Time Protocol)，它是用来同步网络中各个计算机的时间的协议

SMTP，简单邮件传输协议

DNS，域名解析协议

#### 三、

##### 1、http和socket性能比较

首先http是应用层协议，基于传输层TCP协议，它在TCP协议之上主要解决的问题就是如何包装数据；

socket是对TCP/IP协议的封装，它本身并不是协议，它是一个调用接口（API）。

socket连接和http连接也有所不同。

单从这个角度来说，socket的数据传输性能肯定比http要好，但是我们讲性能的时候，不能单纯从原理考虑，还需要对应到具体的场景，比如网络游戏，肯定是选择socket因为它数据传输快，满足网络游戏对传输速率的要求；但是对于基于浏览器的web应用，肯定是要基于相应的http协议。

**socket优点**：

​	1.传输数据为字节级，传输数据可自定义，数据量小。相应的移动端开发，手机费用低

​	2.传输数据时间短，性能高

​	3.适合C/S之间信息实时交互

​	4.可以加密，数据安全性高

**socket缺点**： 

​	1.需要对传输的数据进行解析，转化为应用级的数据

​	2.对开发人员的开发水平要求高

​	3.相对于Http协议传输，增加了开发量

**http优点**：

​	1.基于应用级的接口使用方便

​	2.要求的开发水平不高，容错性强

**http缺点**： 

​	1.传输速度慢，数据包大。

​	2.如实现实时交互，服务器性能压力大

​	3.数据传输安全性差

**Socket适用场景**：网络游戏，银行交互，支付。

**http适用场景**：公司OA服务，互联网服务