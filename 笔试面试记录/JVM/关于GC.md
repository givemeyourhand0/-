#### 1.G1回收器和其他回收器有什么区别？

- G1是Garbage First的意思，基于标记-整理算法，可以做到在基本不影响吞吐量的前提下，完成低停顿的内存回收。
- 其他回收器的回收范围都是整个新生代或老年代，但是G1把堆（包括新生代、老年代）划分为多个大小固定的独立区域，跟踪这些区域的垃圾堆积情况，维护一个优先列表，每次根据允许的垃圾回收时间，优先收集垃圾最多的区域（这就是Garbage First的由来）。

####2.垃圾回收为什么会有停顿？哪些对象可作为GC Roots?

- 因为CMS之前的回收器，都不能做到“你妈妈在打扫房间的时候你还能同时往地上扔纸屑。”，他们无论是单线程还是多线程都必须停掉用户线程。
- GC Roots
  - 栈帧的本地变量表中的对象引用；
  - 方法区的类静态属性引用的对象；
  - 方法区的常量引用的对象；
  - 本地方法栈中的JNI引用的对象。

#### 3.垃圾回收分带收集算法。为什么会有两个survivor区？new一个对象会保存在哪里？

- 新生/老年代。
- 两个Survivor区/一个Eden区，这个是在复制算法里的东西
- new一个对象保存在Eden区，一个Survivor保存上一次GC后存活的对象；一次GC后把Eden和Survivor区存活的对象复制到另一个Survivor区。比例1:1或者8：1：1，因为大多数新生代对象朝生夕死，但不排除特殊情况，所以老年代一般用标记-清除/整理算法。

#### 4、java内存泄漏

- 为什么会导致内存泄漏？

  一些已经不用的对象被比它生命周期长很多的其他对象引用，更糟的是这个不用的对象内还引用了别的对象。比如将**HashMap、ArrayList**的集合对象声明为static时，它们的生命周期就会和应用程序一样长。

- 什么工具查内存泄露。

  - jmap是JDK自带的一个工具，`jmap -heap 1234`，1234是进程号。


  - eclipse mat打开heap.bin
  - 还有知道一个监控JVM的工具，叫plumbr