

##### 1、静态代理和动态代理的区别。

- http://www.cnblogs.com/cenyu/p/6289209.html这个链接讲的很清楚。

- 什么是代理？

   为某个对象提供一个代理，以控制对这个对象的访问。 代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。 

- 区别

  - 两者的具体实现
    - 静态代理类维护一个目标对象，定义同名的方法，方法中调用委托类的方法，在该调用前后做一些事情。
    - 动态代理类维护一个目标对象，之后给目标对象生成代理对象，生成代理对象是通过Proxy.newProxyInstance()方法生成，这个方法需要三个参数，ClassLoader、interfaces和InvocationHandler对象，InvocationHandler对象需要重载invoke()方法，该方法中才是代理类的具体执行逻辑。
  - 代理类的生成时间不同
    - **静态代理**就是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。 
    - **动态代理**类的源码是在程序运行期间由JVM根据反射等机制动态的生成。代理类和委托类的关系是在程序运行时确定。 
  - 代理多个方法时
    - 静态代理如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。 还有如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。 
    - 动态代理与静态代理相比，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。
  - 静态代理中目标对象和代理对象必须实现同一个接口；动态代理中目标对象必须实现接口，代理对象不需要实现接口。所以java动态代理仅仅局限于接口。

##### 2、动态代理怎么实现的。动态代理为什么需要接口？

http://rejoy.iteye.com/blog/1627405这个链接讲的很清楚。-

- 动态代理为什么需要接口？
  - 因为生成的代理类需要通过反射机制得到method对象，将其传参给invocationHandler增强类，invocationHandler中的invoke方法会通过method对象的invoke（目标对象，参数）方法调用目标对象的业务方法。

#####3、Cglib实现代理类

上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理

Cglib代理,也叫作**子类代理**,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.

- JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.
- Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)
- Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.

##### 4、三个代理方式的区别

- 静态代理是通过在代码中显式定义一个业务实现类一个代理，在代理类中对同名的业务方法进行包装，用户通过代理类调用被包装过的业务方法；
- JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；
- CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；

##### 5、深拷贝和浅拷贝的区别

- 浅拷贝是指在拷贝对象时，对于基本数据类型的变量会重新复制一份，而对于引用类型的变量只是对引用进行拷贝，没有对引用指向的对象进行拷贝。
- 而深拷贝是指在拷贝对象时，同时会对引用指向的对象进行拷贝
- 区别就在于是否对  对象中的引用变量所指向的对象进行拷贝。

##### 6、如何理解java接口？

- 接口就是招牌
- 比如你去吃饭，看见KFC这个招牌就知道它卖炸鸡腿（方法实现）。那为什么我要定义接口呢，直接卖炸鸡腿就好了（直接写实现方法）。这样做可以，但是没有挂KFC的招牌，我们就不能直接冲进店里要炸鸡腿了。
- 不挂招牌，我们要么进店里问，你卖不卖炸鸡腿啊，卖不卖圣代啊（反射），但是这样一家一家问，非常麻烦。要么我们就要记住，xxx路xxx号卖炸鸡，xxx路xxx号卖圣代（硬编码）。很显然我们这样做要记住的东西很多。而且，有新的店卖炸鸡腿，我们也不可能知道（不利于扩展性）。

##### 7、如何理解依赖注入？

